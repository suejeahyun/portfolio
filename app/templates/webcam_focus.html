{% extends "base.html" %} {% block content %}
<link
  rel="stylesheet"
  href="{{ url_for('static', filename='css/cctv_style.css') }}"
/>
<div class="focused-webcam-container">
  <h1>{{ cctv.location }} (CCTV ID: {{ cctv.cctv_id }})</h1>
  <img
    id="focused-video"
    src="/video-stream/{{ cctv.cctv_id }}/behavior"
    alt="Live Stream"
    class="focused-video"
  />
  <div class="button-container">
    <button onclick="switchStream('object')">객체 탐지</button>
    <button onclick="switchStream('density')">밀집도</button>
    <button onclick="switchStream('behavior')">이상 행동</button>
    <button onclick="captureImage()">캡처</button>
  </div>
</div>

<script>
  function switchStream(modelType) {
    const videoElement = document.getElementById("focused-video");

    // src를 변경하여 새로운 스트리밍 모델로 변경
    videoElement.src = `/video-stream/{{ cctv.cctv_id }}/${modelType}`;

    // 비디오 요소가 로드된 후 화면을 새로 업데이트
    videoElement.onload = () => {
      console.log(`Stream switched to: ${modelType}`);
      // 로드가 완료된 후 비디오 요소의 크기를 다시 설정하는 것도 고려할 수 있습니다.
      videoElement.style.display = "block"; // 기존 화면을 다시 보여줍니다.
    };

    // 만약 비디오 로딩 중에 이전 화면을 숨기고 새로 로드되었을 때만 보이게 하고 싶다면
    videoElement.style.display = "none"; // 로딩 중 숨깁니다.
  }

  async function captureImage() {
    const videoElement = document.getElementById("focused-video");
    const canvas = document.createElement("canvas");
    canvas.width = videoElement.width;
    canvas.height = videoElement.height;

    const context = canvas.getContext("2d");
    context.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

    // 캡처된 이미지를 데이터 URL로 변환
    const imageData = canvas.toDataURL("image/jpeg");

    // 서버에 이미지 저장 요청
    const response = await fetch("/save-capture", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        cctv_id: "{{ cctv.cctv_id }}",
        image_data: imageData,
      }),
    });

    if (response.ok) {
      alert("이미지가 성공적으로 저장되었습니다.");
    } else {
      alert("이미지 저장 중 오류가 발생했습니다.");
    }
  }

  // 페이지 로드 후 밀집도 모니터링 시작
  setInterval(monitorDensity, 5000); // 5초마다 밀집도 확인
</script>
{% endblock %}
